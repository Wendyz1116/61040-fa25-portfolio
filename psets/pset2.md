# Problem Set 2: Composing Concepts

## 1. Concept Questions

The `NonceGeneration` concept ensures that the short strings it generates will be unique and not result in conflicts.  
What are the contexts for, and what will a context end up being in the URL shortening app?  

* We want multiple contexts because there are different base URLs. So across different `UrlBase`, people should be able to use the same suffix or strings generated by `NonceGeneration`. The contexts would be the different `UrlBase`.

---

Why must the `NonceGeneration` store sets of used strings? One simple way to implement the `NonceGeneration` is to maintain a counter for each context and increment it every time the `generate` action is called. In this case, how is the set of used strings in the specification related to the counter in the implementation? (In abstract data type lingo, this is asking you to describe an abstraction function.)  

* The used string set is needed so the system won’t have the same URL mapping to multiple target URLs. This would make it hard for a user to reach their goal target URL since the shortened URL may actually lead them to another random target. A counter could be used instead, with each number corresponding to a string. The set of used strings in the spec corresponds to all the strings generated from the numbers less than the current counter.

---

One option for nonce generation is to use common dictionary words (in the style of yellkey.com, for example), resulting in more easily remembered shortenings. What is one advantage and one disadvantage of this scheme, both from the perspective of the user? How would you modify the `NonceGeneration` concept to realize this idea?  

* More memorable and readable URLs are easier for users to recall and share verbally. But there’s a more limited pool compared to random alphanumerics, possibly leading to collisions sooner. Also, generated nonces might be confusing and could actually be harder to remember if they are completely random words and not related to the actual link. We can modify the `NonceGeneration` concept so that instead of generating arbitrary strings, it generates a nonce from a predefined dictionary of words, ensuring uniqueness by marking each chosen word as used within its context.


## 2. Synchronization

In the first sync (called generate), the `Request.shortenUrl` action in the when clause includes the `shortUrlBase` argument but not the `targetUrl` argument. In the second sync (called register) both appear. Why is this?  

- In generate, we’re just creating a unique suffix/nonce in the `shortUrlBase` context. We don’t care about the `targetUrl` yet because we’re not doing anything with it. In register though, we’re creating a mapping from a nonce to the `targetUrl` so now it needs it as an argument.

---

The convention that allows names to be omitted when argument or result names are the same as their variable names is convenient and allows for a more succinct specification. Why isn’t this convention used in every case?  

- Sometimes arguments or results have different, more descriptive names compared to the variables they bind to. Sometimes writing them explicitly can also avoid ambiguity, especially when there are a lot of variables.

---

Why is the request action included in the first two syncs but not the third one?  

- The first two syncs should be triggered by explicit user requests to generate a shortened URL or register one. While the `setExpiry` should just be triggered automatically when a URL is registered.

---

Suppose the application did not support alternative domain names, and always used a fixed one such as “bit.ly.” How would you change the synchronizations to implement this?  

- In this case, the `shortUrlBase` argument would no longer be necessary. So, I would remove `shortUrlBase` from both the generate and register and hardcode “bit.ly” into the code implementation.

---

These synchronizations are not complete; in particular, they don’t do anything when a resource expires. Write a sync for this case, using appropriate actions from the ExpiringResource and URLShortening concepts.  

```text
sync deleteExpired
  when ExpiringResource.expireResource(): (shortUrl)
  then UrlShortening.delete(shortUrl)
````

---

## 3. Extending the design

### Concepts

**Analytics**

```text
concept Analytics
  purpose provide counts of accesses to short URLs
  principle each short URL has an associated access count
  state
    a set of Records with
      shortUrl String
      accessCount Number
  actions
    createRecord(shortUrl: String)
      require a record for shortUrl doesn’t already exist 
      effect creates a new record for shortUrl with accessCount = 0
    increment(shortUrl: String)
      require a record exists for shortUrl
      effect increases accessCount of shortUrl by 1
    getCount(shortUrl: String): (count: Number)
      require a record exists for shortUrl
      effect returns the accessCount of shortUrl
```

**Ownership**

```text
concept Ownership
  purpose control access to analytics
  principle only the user who registered the shortening can view its analytics
  state
    a set of Owners with
      userId String
      owned set of String
  actions
    registerOwnership(userId: String, shortUrl: String)
      effect associates shortUrl with userId
    authorize(userId: String, shortUrl: String): (authorized: Boolean)
      effect returns true if shortUrl is in the userId’s owned set, false otherwise
```

---

### Synchronizations

**Sync 1: When a shortening is created**

```text
sync createShortUrlAnalytics
  when
    Request.shortenUrl(userId, targetUrl, shortUrlBase)
      NonceGeneration.generate(): (nonce)
    UrlShortening.register(shortUrlSuffix: nonce, shortUrlBase, targetUrl): (shortUrl)
  then
    Analytics.createRecord(shortUrl)
    Ownership.registerOwnership(userId, shortUrl)
```

**Sync 2: When a shortening is translated to target**

```text
sync recordAccess
  when UrlShortening.lookup(shortUrl): (targetUrl)
  then Analytics.increment(shortUrl)
```

**Sync 3: When a user examines analytics**

```text
sync viewAnalytics
  when Request.getAnalytics(userId, shortUrl)
  then
    if Ownership.authorize(userId, shortUrl):
      Analytics.getCount(shortUrl): (count)
```

---

### Assessing Modularity with Feature Requests

* **Allowing users to choose their own short URLs**

  Extend `UrlShortening.register` since it already takes a custom `UrlBase`.
  No change needed to **Analytics** or **Ownership**.

* **Using the “word as nonce” strategy to generate more memorable short URLs**

  Modify the `NonceGeneration` concept to use a dictionary-based generation method.
  No change needed to **Analytics** or **Ownership**.

* **Including the target URL in analytics**

  Update records in **Analytics** to include `targetUrl: String`.
  Add a new action: `getCountByTarget(targetUrl): Number`.

* **Generate short URLs that are not easily guessed**

  Modify `NonceGeneration` to use cryptographically secure randomness instead of counters.
  No change needed to **Analytics** or **Ownership**.

* **Supporting reporting of analytics to creators of short URLs who have not registered as users**

  This is undesirable and should not be included because it would break privacy concerns. It conflicts with the Ownership principle (“only the creator can view analytics”). It would require removing or weakening that restriction, by making analytics public, or attaching analytics to links themselves so anyone with the short Url can view.